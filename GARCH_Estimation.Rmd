---
title: "GARCH parameters and quantiles estimation"
author: "Jose Augusto Fiorucci"
date: "22/12/2021"
output: pdf_document
---

```{r setup, include=FALSE, echo=TRUE}
knitr::opts_chunk$set(echo = TRUE)
require(quantmod)
options("getSymbols.warning4.0"=FALSE)
require(magrittr)
require(fGarch)
require(bayesDccGarch) #https://github.com/jafiorucci/bayesDccGarch/blob/main/bayesDccGarch_2.1.tar.gz
require(xts)
require("WeightedPortTest")
set.seed(9999)
```


# Input
```{r, echo=TRUE}
symbol = "BOVA11.SA"
from=as.Date('2000-01-01')
to=as.Date('2017-12-31')
C_Trend = 0.95
C_Reaction = 0.50
```

# Data download
```{r, echo=TRUE}
x <- getSymbols.yahoo(symbol,auto.assign = FALSE, from=from, to=to)
```


## High and Low
```{r, echo=TRUE, fig.height=4, out.width = '50%', fig.align = "center"}
H <- Hi(x)
L <- Lo(x)
C <- Cl(x)
plot(cbind(H,L))
```


## Returns
```{r, echo=TRUE, fig.height=4, out.width = '50%', fig.align = "center"}
y <- cbind( diff(log(H)),  diff(log(L)) )
y <- na.omit(y)
y %>% cor() # Returns correlation
plot(y)
```


## Autocorrelation
```{r, echo=TRUE, fig.height=4, out.width = '50%', fig.align = "center"}
acf(y[,1])
acf(y[,2])
```



## Cross correlation
```{r, echo=TRUE, fig.height=4, out.width = '50%', fig.align = "center"}
ccf(as.ts(y[,1]),as.ts(y[,2]))
```


## Volatility verification
```{r, echo=TRUE, fig.height=4, out.width = '50%', fig.align = "center"}
acf(y[,1]^2)
acf(y[,2]^2)
```


<!-- ######################################################################### -->

# Bivariate DCC-GARCH

We will consider the DCC-GARCH to model the volatility of $y = (r_H, r_L)'$, where $r_H$ and $r_L$ denote the $100\times$log-returns from hight's and low's observations.

```{r, echo=TRUE, out.width = '90%', fig.align = "center"}
# returns
mY <- 100*y 

# generates the Markov Chain
start <- Sys.time()

out <- bayesDccGarch(mY, control=list(print=FALSE, nPilotSim=3000))

out2 <- increaseSim(out, nSim=50000)
	
out <- window(out2, start=20000, thin=10)
rm(out2)

end <- Sys.time()

# elapsed time
end-start


## Estimative of parameters
parEst <- summary(out)$statistics[,'Mean']


# plot Markov Chain
plot(out$MC)


## Markov Chain convergence
out$MC %>% geweke.diag()



## Model adequability / residual hypothesis verification
Vol <- xts(out$H[,c("H_1,1","H_2,2")], order.by=index(y)) # estimated volatility
r <- mY / sqrt(Vol) # Standard Residuals

par(mfrow=c(3,2))

plot(r[,1], main="e_H")
plot(r[,2], main="e_L")


# Autocorrelation test
Box.test(r[,1] %>% tail(1000), lag = 10, type ="Ljung-Box", fitdf = 0)
Box.test(r[,1] %>% tail(1000), lag = 15, type ="Ljung-Box", fitdf = 0)
Weighted.Box.test(r[,1] %>% tail(1000), lag = 10, type ="Ljung-Box", fitdf = 0)
Weighted.Box.test(r[,1] %>% tail(1000), lag = 15, type ="Ljung-Box", fitdf = 0)

Box.test(r[,2] %>% tail(1000), lag = 10, type ="Ljung-Box", fitdf = 0)
Box.test(r[,2] %>% tail(1000), lag = 15, type ="Ljung-Box", fitdf = 0)
Weighted.Box.test(r[,2] %>% tail(1000), lag = 10, type ="Ljung-Box", fitdf = 0)
Weighted.Box.test(r[,2] %>% tail(1000), lag = 15, type ="Ljung-Box", fitdf = 0)


# Volatility test
acf(r[,1]^2 %>% tail(1000), main="e_H^2")
acf(r[,2]^2 %>% tail(1000), main="e_L^2")

Box.test(r[,1]^2 %>% tail(1000), lag = 10, type ="Ljung-Box", fitdf = 0)
Box.test(r[,1]^2 %>% tail(1000), lag = 15, type ="Ljung-Box", fitdf = 0)
Weighted.Box.test(r[,1]^2 %>% tail(1000), lag = 10, type ="Ljung-Box", fitdf = 0)
Weighted.Box.test(r[,1]^2 %>% tail(1000), lag = 15, type ="Ljung-Box", fitdf = 0)

Box.test(r[,2]^2 %>% tail(1000), lag = 10, type ="Ljung-Box", fitdf = 0)
Box.test(r[,2]^2 %>% tail(1000), lag = 15, type ="Ljung-Box", fitdf = 0)
Weighted.Box.test(r[,2]^2 %>% tail(1000), lag = 10, type ="Ljung-Box", fitdf = 0)
Weighted.Box.test(r[,2]^2 %>% tail(1000), lag = 15, type ="Ljung-Box", fitdf = 0)

# adequability
r1 <- as.numeric(r[,1]) %>% tail(1000)
x <- rsstd(2000, mean = 0, sd = 1, nu = parEst['nu'], xi =parEst['gamma_1'])
qqplot(x=x, y=r1, xlim=c(-5, 5), ylim=c(-5, 5), ylab="e_H",xlab="sstd")
qqline(r1)

ks.test(r1 , x)

r2 <- as.numeric(r[,2]) %>% tail(1000)
x <- rsstd(2000, mean = 0, sd = 1, nu = parEst['nu'], xi =parEst['gamma_2'])
qqplot(x=x, y=r2 , xlim=c(-5, 5), ylim=c(-5, 5), ylab="e_L",xlab="sstd" )
qqline(r2)

ks.test(r2 , x)



## Estimative of parameters
out$MC %>% summary()


## Conditional Correlation
R <-  xts(out$R[,2], order.by=index(y))


## Volatility
Vol <- xts(out$H[,c("H_1,1","H_2,2")], order.by=index(y))

par(mfrow=c(3,1))
plot(C, main="BOVA11")
plot(Vol)
plot(R, main="R")

```

```{r, echo=TRUE, out.width = '90%', fig.align = "center", comment=NA}
# Prepare input for the expert advisor	
	
## High
#HBOP
High_UB_HBOP = qsstd(p=1-(1-C_Trend)/2, mean = 0, sd = 1, nu = parEst['nu'], xi = parEst['gamma_1'])
#S1
High_UB_S1 = qsstd(p=1-(1-C_Reaction)/2, mean = 0, sd = 1, nu = parEst['nu'], xi = parEst['gamma_1'])


## Low
#B1
Low_LB_B1 = qsstd(p=(1-C_Reaction)/2, mean = 0, sd = 1, nu = parEst['nu'], xi = parEst['gamma_2'])
#LBOP
Low_LB_LBOP = qsstd(p=(1-C_Trend)/2, mean = 0, sd = 1, nu = parEst['nu'], xi = parEst['gamma_2'])

pH <- c(0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 0.975, 0.99, 0.995)
qH <- round(qsstd(p=pH, mean = 0, sd = 1, nu = parEst['nu'], xi = parEst['gamma_1']),3)
names(qH) <- paste0(100*pH,"%")
pL <- 1 - pH
qL <- round(qsstd(p=pL, mean = 0, sd = 1, nu = parEst['nu'], xi = parEst['gamma_2']),3)
names(qL) <- paste0(100*pL,"%")

qC <- rbind(qH, qL)
rownames(qC) <- c("High_UB", "Low_LB")
colnames(qC) <- paste0(100*pL,"%")

m = matrix(NA,nrow=10,ncol=1)
rownames(m) = c("High_UB_HBOP","High_UB_S1","Low_LB_B1","Low_LB_LBOP",
               "High_omega", "High_alpha","High_beta",
			         "Low_omega",  "Low_alpha", "Low_beta" )
colnames(m) = 'Value'

m["High_UB_HBOP",1] = High_UB_HBOP
m["High_UB_S1",1] = High_UB_S1
m["Low_LB_B1",1] =  Low_LB_B1
m["Low_LB_LBOP",1] = Low_LB_LBOP

m["High_omega",1] = parEst["omega_1"]
m["High_alpha",1] = parEst["alpha_1"]
m["High_beta",1] = parEst["beta_1"]

m["Low_omega",1] = parEst["omega_2"]
m["Low_alpha",1] = parEst["alpha_2"]
m["Low_beta",1] = parEst["beta_2"]

# Input for expert advisor
print(qC)
print(round(m,3))
```

